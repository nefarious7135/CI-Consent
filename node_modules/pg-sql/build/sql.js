"use strict";
const minify = require("pg-minify");
/**
 * The representation of a SQL query. Call `compile` to turn it into a SQL
 * string with value placeholders.
 *
 * This object is immutable. Instead of changing the object, new `SQLQuery`
 * values will be returned.
 *
 * The constructor for this class is private and may not be called.
 */
class SQLQuery {
    /**
     * A template string tag that interpolates literal SQL with placeholder SQL
     * values.
     */
    static query(strings, ...values) {
        const items = [];
        // Add all of the strings as raw items and values as placeholder values.
        for (let i = 0; i < strings.length; i++) {
            items.push({ type: 'RAW', text: strings[i] });
            if (i < values.length) {
                const value = values[i];
                // If the value is a `SQLQuery`, add all of its items.
                if (value instanceof SQLQuery) {
                    for (const item of value._items)
                        items.push(item);
                }
                else {
                    items.push({ type: 'VALUE', value });
                }
            }
        }
        return new SQLQuery(items);
    }
    /**
     * Joins multiple queries together and puts a seperator in between if a
     * seperator was defined.
     */
    static join(queries, seperator) {
        const items = [];
        // Add the items of all our queries into the `items` array, adding text
        // seperator items as necessary.
        for (const query of queries) {
            for (const item of query._items)
                items.push(item);
            // If we have a seperator, and this is not the last query, add a
            // seperator.
            if (seperator && query !== queries[queries.length - 1])
                items.push({ type: 'RAW', text: seperator });
        }
        return new SQLQuery(items);
    }
    /**
     * Creates a new query with the raw text.
     */
    static raw(text) {
        return new SQLQuery([{ type: 'RAW', text }]);
    }
    /**
     * Creates a new query with the value. This value will be turned into a
     * placeholder when the query gets compiled.
     */
    static value(value) {
        return new SQLQuery([{ type: 'VALUE', value }]);
    }
    /**
     * Creates an identifier query. Each name will be escaped, and the
     * names will be concatenated with a period (`.`).
     */
    static identifier(...names) {
        return new SQLQuery([{ type: 'IDENTIFIER', names }]);
    }
    // The constructor is private. Users should use the static `create` method to
    // make a new `SQLQuery`.
    constructor(items) {
        this._items = items;
        this._query = null;
    }
    /**
     * The SQL query text with placeholders for values. The placeholders refer to
     * a value in the `values` array.
     */
    get text() {
        return this.compile().text;
    }
    /**
     * The values used to fill the placeholders in `text`.
     */
    get values() {
        return this.compile().values;
    }
    /**
     * Compiles this SQL query into a Postgres query. Memoized so it only does the
     * work once.
     */
    compile() {
        // If we donâ€™t yet have a compiled query, create one.
        if (this._query == null)
            this._query = compile(this._items);
        return this._query;
    }
}
exports.SQLQuery = SQLQuery;
/**
 * Compiles a list of `SQLItem`s into a single `PGQuery`.
 */
function compile(items) {
    // Create an empty query object.
    const query = {
        text: '',
        values: [],
    };
    const localIdentifiers = new Map();
    for (const item of items) {
        switch (item.type) {
            // If this is just raw text, we add it directly to the query text.
            case 'RAW': {
                query.text += item.text;
                break;
            }
            // If we got a value SQL item, add a placeholder and add the value to our
            // placeholder values array.
            case 'VALUE': {
                query.text += `$${query.values.length + 1}`;
                query.values.push(item.value);
                break;
            }
            // If we got an identifier type, escape the strings and get a local
            // identifier for non-string identifiers.
            case 'IDENTIFIER': {
                query.text += item.names.map((name) => {
                    if (typeof name === 'string')
                        return escapePGIdentifier(name);
                    if (!localIdentifiers.has(name))
                        localIdentifiers.set(name, `__local_${localIdentifiers.size}__`);
                    return localIdentifiers.get(name);
                }).join('.');
                break;
            }
        }
    }
    // Minify the query text before returning it.
    query.text = minify(query.text);
    return query;
}
/**
 * Escapes a Postgres identifier. Adapted from the [`pg` module][1].
 *
 * [1]: https://github.com/brianc/node-postgres/blob/a536afb1a8baa6d584bd460e7c1286d75bb36fe3/lib/client.js#L255-L272
 */
function escapePGIdentifier(str) {
    let escaped = '"';
    for (const c of str) {
        if (c === '"')
            escaped += c + c;
        else
            escaped += c;
    }
    escaped += '"';
    return escaped;
}
// Create the SQL interface we export.
exports.sql = Object.assign((strings, ...values) => SQLQuery.query(strings, ...values), {
    join: SQLQuery.join,
    raw: SQLQuery.raw,
    value: SQLQuery.value,
    ident: SQLQuery.identifier,
});
